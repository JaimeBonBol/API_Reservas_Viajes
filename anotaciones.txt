# Primer_MicroServicio
Mi primer microservicio
Capa	                Responsabilidad principal
Controlador	            Recibe peticiones HTTP, las valida superficialmente y llama al servicio.
Servicio	            Contiene la l√≥gica de negocio (como verificar plazas y actualizar vuelo).
Repositorio	            Accede a la base de datos (CRUD, consultas, etc.).

1. Controller (Capa web)

   üì° Se encarga de recibir y responder a las peticiones HTTP.

   ‚úÖ Valida las entradas (con @RequestBody, @Valid, etc.).

   üöö Pasa los datos a la capa de servicio para procesarlos.

   üì¶ Devuelve el resultado como respuesta al cliente.

No debe tener l√≥gica compleja. Si metes l√≥gica aqu√≠, se vuelve dif√≠cil de mantener y probar.
2. Service (Capa de negocio)

   üß† Aqu√≠ va la l√≥gica de negocio: reglas, validaciones, c√°lculos, decisiones.

   Ejemplos:

        Hay plazas en el vuelo

        ¬øEl hotel est√° disponible?

        ¬øDebo lanzar un error o guardar la reserva?

Es el coraz√≥n del sistema: el "qu√© hacer".
3. Repository (Capa de acceso a datos)

   üíæ Se comunica directamente con la base de datos.

   No toma decisiones. Solo guarda, actualiza, busca o borra datos.

la raz√≥n por la que en el body de la Reserva usamos esta forma:

"vueloAsociado": { "id": 1 },
"hotelAsociado": { "id": 2 }

es porque est√°s trabajando con objetos completos en una relaci√≥n JPA, y no solo con IDs como campos planos.

 1. Reserva contiene objetos enteros, no solo IDs:

@ManyToOne(fetch = FetchType.LAZY)
@JoinColumn(name = "vuelo_asociado")
private Vuelo vueloAsociado;

@ManyToOne(fetch = FetchType.LAZY)
@JoinColumn(name = "hotel_asociado")
private Hotel hotelAsociado;

‚û°Ô∏è Eso significa que el campo espera un objeto de tipo Vuelo y Hotel, no simplemente un Long con el ID.
üß† 2. Jackson (la librer√≠a de JSON de Spring Boot) necesita un objeto v√°lido

Cuando haces un POST con JSON, Spring (a trav√©s de Jackson) intenta deserializarlo a tu clase Java.

Entonces este:

"vueloAsociado": { "id": 1 }

Jackson lo interpreta como:
üëâ ‚Äúcrear un objeto Vuelo con ID = 1, los dem√°s campos me dan igual‚Äù.

Esto permite que Spring lo pase como un Vuelo a tu servicio, y all√≠ ya puedes buscar el objeto completo por ID.


la relaci√≥n entre Vuelo/Hotel y Reserva es una relaci√≥n padre-hijo porque:

    Un Vuelo (o un Hotel) puede tener muchas reservas asociadas: 1 vuelo ‚Üí N reservas.

    Cada Reserva est√° asociada a un solo Vuelo y un solo Hotel.

Es decir, desde el punto de vista del dise√±o:

    Vuelo y Hotel son la entidad ‚Äúdue√±a‚Äù o ‚Äúpadre‚Äù porque existen independientemente y contienen una colecci√≥n de reservas.

    Reserva es la entidad ‚Äúhija‚Äù o dependiente, ya que su existencia est√° ligada a un vuelo y un hotel espec√≠ficos (adem√°s tiene claves for√°neas a estas tablas).

Por eso:

    En JPA, en el lado del padre (Vuelo y Hotel) defines un @OneToMany ‚Äî un vuelo tiene muchas reservas.

    En el lado hijo (Reserva) defines un @ManyToOne ‚Äî cada reserva apunta a un solo vuelo y hotel.

En t√©rminos de serializaci√≥n JSON:

    Cuando serializas un Vuelo o un Hotel (padres), tiene sentido que incluyas la lista de reservas que pertenecen a ese vuelo o hotel.

    Cuando serializas una Reserva (hija), tiene sentido que muestres el vuelo y el hotel asociados, pero no necesariamente todas las reservas que hay en ese vuelo o hotel porque eso puede generar un bucle infinito (serializar reserva ‚Üí vuelo ‚Üí reservas ‚Üí reserva ‚Üí ‚Ä¶).

Por eso, en Jackson:

    @JsonManagedReference va en la propiedad del padre que tiene la lista de hijos.

    @JsonBackReference va en la propiedad del hijo que apunta al padre, para romper la recursi√≥n.
